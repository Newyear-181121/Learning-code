Index: src/com/mooc/unit_3/迷宫问题/StackNode.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/mooc/unit_3/迷宫问题/StackNode.java	(date 1590396095842)
+++ src/com/mooc/unit_3/迷宫问题/StackNode.java	(date 1590396095842)
@@ -0,0 +1,13 @@
+package com.mooc.unit_3.迷宫问题;
+
+/**
+ * 链表栈节点
+ */
+public class StackNode {
+    public StackNode next;
+
+    public int id;
+    public int x;
+    public int y;
+    public int direction;
+}
Index: src/com/mooc/unit_3/迷宫问题/Demo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/mooc/unit_3/迷宫问题/Demo.java	(date 1590400776543)
+++ src/com/mooc/unit_3/迷宫问题/Demo.java	(date 1590400776543)
@@ -0,0 +1,95 @@
+package com.mooc.unit_3.迷宫问题;
+
+/**
+ * 这个链表是反向链表，，不停的再头节点加新的 栈头。
+ */
+public class Demo {
+    int[][] maze = {{1,1,0,0},{1,1,1,0},{1,0,0,0},{1,1,1,1}};
+    /**
+     * 判断方向是否能走，
+     * 能则入栈。当发现所有方向都不可行时，实现退栈并且找到新的路。
+     * @param s  栈
+     */
+    public void advance(LinkStack s){
+        StackNode p = s.top;
+        int i = 0;
+        while (true) {
+            if (li(p.direction) != i && maze[p.y + gety(i)][p.x + getx(i)] == 1) {
+                push(s, (p.x + getx(i)), p.y + gety(i), i);
+                break;
+            }
+            i++;
+            if (i == 4){ // 如果四个方向都不能走，
+                pop(s);
+                back(s);
+                break;
+            }
+        }
+    }
+
+    /**
+     * 主要用来将当前可走的方向和那个方向对应的坐标存入栈中，
+     *      并且将上一节点的方向值修改为栈顶的方向。
+     * @param s 栈
+     * @param x
+     * @param y
+     * @param direction
+     */
+    public void push(LinkStack s,int x,int y,int direction){
+        StackNode p = new StackNode();
+        p.x = x;
+        p.y = y;
+        p.direction = direction;
+        p.next = s.top;
+        s.top = p;
+        if (p.next != null){
+            p.next.direction = direction;
+        }
+        System.out.printf("建立x=%2d y=%2d d=%d\n",p.next.y,p.next.x,p.next.direction);
+    }
+
+    /**
+     * 用来转换下一个方向，判断下一个可走的方向并且存入栈中。
+     * @param s
+     */
+    public void back(LinkStack s){
+        StackNode p = s.top;
+       // int i=
+    }
+
+    /**
+     * 如果当前方向不可行就删除栈顶元素。
+     * @param s
+     */
+    public void pop(LinkStack s){
+        StackNode p = s.top;
+        if (p != null){
+            s.top= p.next;
+            System.out.printf("撤销x=%2d y=%2d d=%d\n",s.top.y,s.top.x,s.top.direction);
+        }
+    }
+
+    /**
+     * 取反方向
+     * @param x
+     */
+    public int li(int x){
+        int a[] = {2,3,0,1};
+        return a[x];
+    }
+
+    /**
+     * 根据方向获取，坐标变化
+     * @param x
+     * @return
+     */
+    public int gety(int x){
+        int a[]={1,0,-1,0};
+        return a[x];
+    }
+
+    public int getx(int x){
+        int a[] = {0,1,0,-1};
+        return a[x];
+    }
+}
Index: .idea/encodings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"Encoding\" native2AsciiForPropertiesFiles=\"true\" defaultCharsetForPropertiesFiles=\"UTF-8\">\r\n    <file url=\"file://$PROJECT_DIR$/src/ny/how2j/j_1_java_se/collection/TestCollection2_1.java\" charset=\"UTF-8\" />\r\n    <file url=\"file://$PROJECT_DIR$/src/ny/how2j/j_1_java_se/collection_2/Node2_2.java\" charset=\"UTF-8\" />\r\n    <file url=\"file://$PROJECT_DIR$/src/ny/how2j/j_1_java_se/digit/TestNumber01.java\" charset=\"UTF-8\" />\r\n    <file url=\"file://$PROJECT_DIR$/src/ny/how2j/j_1_java_se/exception/TestException01.java\" charset=\"UTF-8\" />\r\n    <file url=\"file://$PROJECT_DIR$/src/ny/how2j/j_1_java_se/exception/TestException2_1.java\" charset=\"UTF-8\" />\r\n    <file url=\"file://$PROJECT_DIR$/src/ny/how2j/j_1_java_se/file/TestFile1_3.java\" charset=\"UTF-8\" />\r\n    <file url=\"file://$PROJECT_DIR$/src/ny/how2j/j_1_java_se/review/character/Hero.java\" charset=\"UTF-8\" />\r\n    <file url=\"PROJECT\" charset=\"UTF-8\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/encodings.xml	(revision 1bcd40fd97ad80595929f9ad938335416734e187)
+++ .idea/encodings.xml	(date 1590403243736)
@@ -7,6 +7,7 @@
     <file url="file://$PROJECT_DIR$/src/ny/how2j/j_1_java_se/exception/TestException01.java" charset="UTF-8" />
     <file url="file://$PROJECT_DIR$/src/ny/how2j/j_1_java_se/exception/TestException2_1.java" charset="UTF-8" />
     <file url="file://$PROJECT_DIR$/src/ny/how2j/j_1_java_se/file/TestFile1_3.java" charset="UTF-8" />
+    <file url="file://$PROJECT_DIR$/src/ny/how2j/j_1_java_se/lambda/TestLambda1_2.java" charset="UTF-8" />
     <file url="file://$PROJECT_DIR$/src/ny/how2j/j_1_java_se/review/character/Hero.java" charset="UTF-8" />
     <file url="PROJECT" charset="UTF-8" />
   </component>
Index: src/com/mooc/unit_3/栈/顺序栈/Stack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/mooc/unit_3/栈/顺序栈/Stack.java	(date 1590392062001)
+++ src/com/mooc/unit_3/栈/顺序栈/Stack.java	(date 1590392062001)
@@ -0,0 +1,59 @@
+package com.mooc.unit_3.栈.顺序栈;
+
+/**
+ *
+ */
+public class Stack {
+    private int maxSize;
+    private int[] list;
+    private int top;
+
+    /**
+     * 初始化
+     * @param maxSize
+     */
+    public Stack(int maxSize){
+        int[] list = new int[maxSize];
+        this.list = list;
+        top = -1;
+    }
+
+    public boolean isEmpty(){
+        return top == -1;
+    }
+
+    public boolean isFull(){
+        return top == maxSize -1;
+    }
+
+    public void push(int x){
+        if (!isFull()) {
+            top++;
+            list[top] = x;
+        }else {
+            throw new RuntimeException("栈满，无法入栈");
+        }
+    }
+    public int pop(){
+        int res ;
+        if (!isEmpty()){
+            res = list[top];
+            top--;
+        } else {
+            throw new RuntimeException("栈空，无法出栈");
+        }
+        return res;
+    }
+
+    public int getTop(){
+        if (!isEmpty()){
+            return list[top];
+        } else {
+            throw new RuntimeException("栈空，无法出栈");
+        }
+    }
+
+    public void setEmpty(){
+        top = -1;
+    }
+}
Index: src/com/mooc/unit_3/栈/阶乘.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/mooc/unit_3/栈/阶乘.java	(date 1590392932109)
+++ src/com/mooc/unit_3/栈/阶乘.java	(date 1590392932109)
@@ -0,0 +1,24 @@
+package com.mooc.unit_3.栈;
+
+public class 阶乘 {
+    public static int res(int n){
+        if (n == 1){
+            return 1;
+        }
+        System.out.println(n ); res2(n-1);
+        return n * res(n -1);
+
+    }
+    public static void res2(int n){
+        if (n == 1){
+            return ;
+        }
+        System.out.print("*" + n);
+        res2(n -1);
+    }
+
+    public static void main(String[] args){
+        int result = res(3);
+        System.out.println(result);
+    }
+}
Index: src/com/mooc/unit_3/栈/汉诺塔.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/mooc/unit_3/栈/汉诺塔.java	(date 1590393657698)
+++ src/com/mooc/unit_3/栈/汉诺塔.java	(date 1590393657698)
@@ -0,0 +1,28 @@
+package com.mooc.unit_3.栈;
+
+public class 汉诺塔 {
+    /**
+     *
+     * @param n
+     * @param x 源位置
+     * @param y 辅助位置
+     * @param z 目标位置
+     */
+    public void hanoi(int n,char x,char y,char z){
+        if (n == 1){
+            move(x,1,z);
+        } else {
+            hanoi(n-1,x,z,y);
+            move(x,n,z);
+            hanoi(n-1,y,x,z);
+        }
+    }
+    public void move(char x,int y,char z ){
+        System.out.println("第" + y+"个圆盘" +x+"-->"+z);
+    }
+
+    public static void main(String[] args) {
+        汉诺塔 a = new 汉诺塔();
+        a.hanoi(3,'a','b','c');
+    }
+}
Index: src/com/mooc/unit_3/迷宫问题/LinkStack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/mooc/unit_3/迷宫问题/LinkStack.java	(date 1590396384783)
+++ src/com/mooc/unit_3/迷宫问题/LinkStack.java	(date 1590396384783)
@@ -0,0 +1,9 @@
+package com.mooc.unit_3.迷宫问题;
+
+/**
+ * 链表栈
+ */
+public class LinkStack {
+    public StackNode top;
+    
+}
Index: src/ny/how2j/j_1_java_se/lambda/TestLambda1_2.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package lambda;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Random;\r\n\r\n\r\n/**\r\n * �����\u0DFDʽ\r\n * @author New year\r\n *\r\n */\r\npublic class TestLambda1_2 {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t\tRandom r = new Random();\r\n\t\tList<Hero> heros = new ArrayList<Hero>();\r\n\t\tfor (int i = 0; i < 5 ;i++) {\r\n\t\t\theros.add(new Hero(\"hero \" + i, r.nextInt(1000),r.nextInt(100)));\r\n\t\t\t\r\n\t\t}\r\n\t\tSystem.out.println(\"��ʼ����ļ��ϣ�\");\r\n\t\tSystem.out.println(heros);\r\n\t\tSystem.out.println(\"ʹ��������ķ�ʽ��ɸѡ��\");\r\n\t\tHeroChecker checker = new HeroChecker() {\r\n\t\t\t@Override\r\n\t\t\tpublic boolean test(Hero h) {\t\t//��д�ӿ�����\r\n\t\t\t\treturn (h.hp>100 && h.damage<50);\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tfilter(heros,checker);\r\n\t\t\r\n\t}\r\n\t\r\n\tprivate static void filter(List<Hero> heros,HeroChecker checker\t) {\r\n\t\tfor (Hero hero : heros) {\r\n\t\t\tif(checker.test(hero))\r\n\t\t\t\tSystem.out.print(hero);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/*\r\n * ����\u05FC��һ���ӿ�HeroChecker���ṩһ��test(Hero)����\r\nȻ��ͨ��������ķ�ʽ��ʵ������ӿ�\r\n \r\nHeroChecker checker = new HeroChecker() {\r\n\tpublic boolean test(Hero h) {\r\n\t\treturn (h.hp>100 && h.damage<50);\r\n\t}\r\n};\r\n \r\n\r\n���ŵ���filter���������checker��ȥ�����жϣ����ַ�ʽ�ͺ���ͨ��Collections.sort�ڶ�һ��Hero����������Ҫ��һ��Comparator������������ȥһ����\r\n*/\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/ny/how2j/j_1_java_se/lambda/TestLambda1_2.java	(revision 1bcd40fd97ad80595929f9ad938335416734e187)
+++ src/ny/how2j/j_1_java_se/lambda/TestLambda1_2.java	(date 1590403184501)
@@ -6,7 +6,7 @@
 
 
 /**
- * �����෽ʽ
+ * 匿名类方式
  * @author New year
  *
  */
@@ -21,12 +21,12 @@
 			heros.add(new Hero("hero " + i, r.nextInt(1000),r.nextInt(100)));
 			
 		}
-		System.out.println("��ʼ����ļ��ϣ�");
+		System.out.println("初始化后的集合：");
 		System.out.println(heros);
-		System.out.println("ʹ��������ķ�ʽ��ɸѡ��");
+		System.out.println("使用匿名类的方式，筛选出");
 		HeroChecker checker = new HeroChecker() {
 			@Override
-			public boolean test(Hero h) {		//��д�ӿ�����
+			public boolean test(Hero h) {		//重写接口内容
 				return (h.hp>100 && h.damage<50);
 			}
 		};
@@ -45,8 +45,8 @@
 }
 
 /*
- * ����׼��һ���ӿ�HeroChecker���ṩһ��test(Hero)����
-Ȼ��ͨ��������ķ�ʽ��ʵ������ӿ�
+ * 首先准备一个接口HeroChecker，提供一个test(Hero)方法
+然后通过匿名类的方式，实现这个接口
  
 HeroChecker checker = new HeroChecker() {
 	public boolean test(Hero h) {
@@ -55,5 +55,5 @@
 };
  
 
-���ŵ���filter���������checker��ȥ�����жϣ����ַ�ʽ�ͺ���ͨ��Collections.sort�ڶ�һ��Hero����������Ҫ��һ��Comparator������������ȥһ����
+接着调用filter，传递这个checker进去进行判断，这种方式就很像通过Collections.sort在对一个Hero集合排序，需要传一个Comparator的匿名类对象进去一样。
 */
Index: src/ny/demo/test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ny.demo;\r\n\r\nimport java.io.IOException;\r\nimport java.net.*;\r\n\r\n/**\r\n * 监听指定端口\r\n */\r\npublic class test {\r\n    public static void main(String[] args) throws IOException {\r\n\r\n        DatagramSocket ds = new DatagramSocket(5555,InetAddress.getByName(\"0.0.0.0\"));\r\n        byte[] buf = new byte[1024];\r\n        DatagramPacket dp_receive = new DatagramPacket(buf, 1024);\r\n        System.out.println(\"udp start listen on 5555\");\r\n        ds.receive(dp_receive);\r\n        System.out.println(\"收到udp消息\");\r\n        System.out.println(\"客户端发送udp端口为\" + dp_receive.getPort());\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/ny/demo/test.java	(revision 1bcd40fd97ad80595929f9ad938335416734e187)
+++ src/ny/demo/test.java	(date 1590403243064)
@@ -17,4 +17,6 @@
         System.out.println("收到udp消息");
         System.out.println("客户端发送udp端口为" + dp_receive.getPort());
     }
+
+    String s = "";
 }
